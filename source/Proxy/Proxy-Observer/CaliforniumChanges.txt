CoapClient: 
	original line: https://github.com/eclipse/californium/blob/f3769602ae52217deead0e92ee95868cd0d35b85/californium-core/src/main/java/org/eclipse/californium/core/CoapClient.java#L1139
	change line 1140: if (response == null || !response.advanced().getOptions().hasObserve() || response.getCode().equals(CoAP.ResponseCode.NOT_ACCEPTABLE)) {
	motivation: the first CoapObserveRelation must be cancelled if the subject started the negotiation
	
Request:
	original line: https://github.com/eclipse/californium/blob/f3769602ae52217deead0e92ee95868cd0d35b85/californium-core/src/main/java/org/eclipse/californium/core/coap/Request.java#L642
	change line 642: 	return isObserveOption(0x000000) || isObserveOption(0x400000) || isObserveOption(0x800000) || isObserveOption(0xc00000);
	motivation: The ObserveRelation must be build also if the observe option is equal to all the possible priority values
	
ObserveRelation:
	original line:
	line 62: private int QoS;
	lines 129-141:
		
		public void setQoS(int QoS) {
			this.QoS = QoS;
		}

		public int getQoS() {
			return QoS;
		}
	lines 265-271:
		public int compareToDesc(ObserveRelation relation) {
			if ( QoS == relation.getQoS() ) 
				return 0;
			if ( QoS > relation.getQoS() )
				return -1;
			return 1;
		}
	motivation: Now the ObserverRelation stores the QoS level
	
CoapResource:
	original line:
	line 157: 	/** Current Server State */
				private ServerState serverState;
	lines 208-220:
			public void setServerState(ServerState serverState) {
				this.serverState = serverState;
				
				if (serverState == ServerState.ONLY_CRITICAL) {
					clearNonCriticalObserveRelations();
				} else if ( serverState == ServerState.UNVAVAILABLE ) {
					clearObserveRelations();
				}
			}
			
			public ServerState getServerState() {
				return serverState;
			}
	lines 575-583:
			public void clearNonCriticalObserveRelations() {
				for (ObserveRelation relation : observeRelations) {
					if (relation.getPriority < 3 )
						relation.cancel();
				}
			}
	motivation: The CoapResource stores also the server state, if the state changes to ONLY_CRITICAL the observeRelation with priority 1-2 needs to be notified and cancelled, if the states changes to UNVAILABLE all the relations need to be notified and cancelled
	
ObserveRelationContainer:

		private HashMap<String, ObserveRelation> observeRelations;
	

	//	public void sort() {
//		List<Map.Entry<String, ObserveRelation> > relations = new ArrayList<>(observeRelations.entrySet());
//        Collections.sort(relations, new Comparator<Map.Entry<String, ObserveRelation>>() { 
//            public int compare(Map.Entry<String, ObserveRelation> o1,  
//                               Map.Entry<String, ObserveRelation> o2) 
//            { 
//            	return (o1.getValue()).compareToDesc(o2.getValue());
//            } 
//        });
//        
//        HashMap<String, ObserveRelation> temp = new LinkedHashMap<String, ObserveRelation>(); 
//        for (Map.Entry<String, ObserveRelation> aa : relations) { 
//            temp.put(aa.getKey(), aa.getValue()); 
//        } 
//        observeRelations = temp;
//	} 

ServerMessadeDeliver:
					relation.setQoS(request.getOptions().getObserve());
	