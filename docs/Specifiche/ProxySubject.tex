\chapter{Modulo ProxySubject}
\section{Descrizione}
Questo modulo permette la gestione della comunicazione tra il \textbf{Proxy} e i \textbf{Subjects} fornendo le informazioni necessarie al modulo \textbf{ProxyObserver}.\\
Le informazioni che dovranno essere mantenute da questo modulo sono tutte quelle necessarie ad evitare comunicazioni non necessarie tra gli osservatori ed i soggetti, in quanto dovrà essere proprio il modulo \textbf{ProxySubject} ad offire le informazioni richieste, qualora sia possibile. \\
In particolare il modulo si occuperà di gestire una struttura dati che dovrà rappresentare il soggeto dal punto di vista dell'osservatore, in particolare offrendo informazioni quali lo stato del soggetto (ovvero quali tipologie di richieste è in grado di accettare), le risorse offerte dal soggetto, in modo tale da non dover sprecare tempo ed energia per richiedere ogni volta se può o meno offrire una detemerminata risorsa su quali risorse il soggetto ha già ricevuto una registrazione, in quanto se un osservatore vuole effettuare una registrazione al proxy su una risorsa a cui un altro osservatore ha fatto la medisima richiesta, con le stesse caratteristiche in termini di priorità, allora quest'ultima non sarà inoltrata al soggetto in quanto il proxy è in grado di poterla gestire in completa autonomia. \\
In aggiunta il modulo  \textbf{ProxySubject} offre anche un meccanismo di cache dei valori ricevuti, in modo tale da memorizzare l'ultimo valore ottenuto da un soggetto in una struttura dati, utile al modulo \textbf{ProxyObserver} qualore dovesse richiedere un valore ad un determinato soggetto, come ad esempio durante la fase di registrazione.
\section{Implementazione}
\subsection{CacheTable}
Questa classe si occupa di mantenere le informazioni ottenute dai soggetti e di renderle disponibili in qualunque momento.
\subsubsection{Inserimento Valori}
Quando viene ricevuto un nuovo valore dai soggetti è necessario inserire il valore nella cache, controllando se era già stato ricevuto un valore relativo a quella registrazione, in tal caso aggiornando il vecchio valore, oppure se inserire un nuovo valore, in quanto quello appena ricevuto risulta essere il primo valore ricevuto relativo alla registrazione associata ad esso. \\
\lstinputlisting[language=Java,firstnumber=28, firstline=28, lastline=40, caption={CacheTable.InsertData}]{../Codice/Java/ProxySubject/CacheTable.java}
\subsubsection{Aggiornamento dei valori}
Per mantenere consistenti i valori presenti in cache è opportuno che questi ultimi siano periodicamente aggiornati - abbiamo scelto una frequenza di aggiornamento di 1Hz - in quanto uno degli elementi su cui si basa l'intero protocollo è il valore MaxAge appartente ad ogni singolo valore, in quanto nel momento in cui tale valore raggiunge lo 0 e non si è ricevuto alcun valore successivo, allora si deve considerare terminato l'ascolto verso il soggetto,e non aspettarsi più alcun valore. \\
\lstinputlisting[language=Java,firstnumber=14, firstline=14, lastline=27, caption={CacheTable.updateTime}]{../Codice/Java/ProxySubject/CacheTable.java}
\subsection{Gestione delle notifiche}
Per gestire le notifiche da parte dei soggetti abbiamo continuato ad apporgiarci a Californium, in particolare definendo una classe ResponseHandler come estenesione della CoAPHandler, in quanto erano necessarie alcune operazioni da effettuare subito dopo la ricezione del messaggio. \\
In particolare la prima operazione da eseguire è quella di discriminare se il messaggio appena ricevuto è critico o meno, risultato ottenuto analizzando il contenuto del messaggio, in quanto la politica di valutazione di un valore è implementata nei soggetti ed ignota al proxy. Questo significa che se al termine del valore è presente il caratte '!' allora significa che il valore ricevuto deve essere gestito come valore critico, altrimenti risulta essere un valore non critico. \\
Discriminato il valore dovrà essere creato un nuovo \textbf{SensorData}, che rappresenta in tutti gli aspetti il valore appena ricevuto, e che dovrà essere inserito in cache. Solo al termine di quest'ultima operazione dovrà esssre informato il modulo \textbf{ProxyObserver} in modo che notifichi il nuovo valore a tutti gli osservatori registrati per tale risorsa. \\
In seguito è riportato solo una parte del codice per la gestione del messaggio, ovvero solo quella ritenuta interessante. \\
\lstinputlisting[language=Java,firstnumber=41, firstline=41, lastline=72, caption={Parte del metodo ResponseHandler.onLoad}]{../Codice/Java/ProxySubject/ResponseHandler.java}
\subsection{Registrator}
Questa classe serve a gestire il processo di registrare, in particolare ad analizzare se quest'ultima risulta essere necessaria o meno, oppure se la vecchia registrazione debba essere aggiornata. \\
\subsubsection{Inserimento di una nuova registrazione}
Una volta ricevuta una richiesta di registrazione da parte di un osservatore è necessario verificare se tale registrazione è necessaria o meno, ed eventualmente portarla a termine mediante il metodo messo a disposizione dalla classe \textbf{Registration}. \\
Per controllare se a seguito della richiesta di registrazione ricevuta al proxy, è necessario inoltrarla al soggetto interessato o se invece le registrazioni già presenti riescono a coprire anche la nuova richiesta, evitando quindi spreco di tempo ed energia da parte del soggetto, è necessario analizzare il soggetto relativo a tale registrazione, la risorsa richiesta e il livello di criticità desiderato: se è già presente una registrazione avente lo stesso soggetto, associata alla stessa risorsa e con un livello di criticità minore rispetto a quello richiesto - in quanto se per esempio venisse fatta una richiesta solo per valori critici ma ce ne fosse una che li copre tutti, allora non sarebbe necessaria adempiere alla richiesta appena arrivata - allora il processo di registrazione verrbbe completato senza consultare il soggetto, in quanto per quest'ultimo non cambierebbe niente. In alternativa se è presente una registrazione con un livello maggiore rispetto a quello richiesto - si prenda ad esempio il caso opposto rispetto a quello illustrato prima - la vecchia registrazione non sarà sufficiente e quindi dovrà essere aggiornata in modo da coprire anche la richiesta appena arrivata. \\
\lstinputlisting[language=Java,firstnumber=13, firstline=13, lastline=59,caption={Registrator.newRegistration e Registrator.RegistrationNeeded}]{../Codice/Java/ProxySubject/Registrator.java}
\subsubsection{Rimozione di una registrazione}
Qualora non si ricevessere più notifiche da parte del soggetto o se tutti gli osservatori - in quanto basta almeno un osservatore interessato per mantenere attiva la registrazione - non desiderassero ricevere più notifiche, risulta necessario rimuovere la registrazione e notificare al soggeto che non siamo più registrati per tale risorsa. \\
\lstinputlisting[language=Java,firstnumber=69, firstline=69, lastline=81,caption={Registrator.removeRegistration}]{../Codice/Java/ProxySubject/Registrator.java}
\subsection{Virtualizzare soggetti e messaggi}
Un aspetto molto importante del modulo \textbf{ProxySubject} è la capacità di virtualizzare sia i soggetti che i messaggi ricevuti da essi, in modo da rendere completamente trasparente il comportamento di nodi sensori per il modulo \textbf{ProxyObserver} e quindi di conseguenza per gli osservatori. \\
Tale scelta di sviluppo ha comportato la possibilità di sviluppare in modo indipendente i protocolli di comunicazione con gli osservatori da una parte e con i soggetti dall'altra, in quanto l'unica cosa a comune risultano essere proprio le strutture dati che \textit{virtualizzano} i soggetti e i messaggi ricevuti da essi.
\subsubsection{SensorNode}
Questa classe è quella che si occupa di gestire un soggetto, mantenendo le informazioni necessarie, il suo URI, le risorse che mette a disposizione, il suo livello di batteria e lo stato in cui opera, che può essere:
\begin{itemize}
  \item \textbf{UNAVAILABLE}: Il sensore non è raggiungibile in quanto le batterie sono scariche.
  \item \textbf{ONLYCRITICAL}: Il livello di batteria è troppo basso quindi il soggetto accetta solo registrazioni critiche.
  \item \textbf{AVAILABLE}: Il livello di batteria è sufficientemente alto per gestire qualsiasi tipo di registrazione
\end{itemize}
\lstinputlisting[language=Java,firstnumber=12, firstline=12, lastline=16,caption={Attributi offerti e gestiti dalla clase SensorNode}]{../Codice/Java/ProxySubject/SensorNode.java}
In particolare per la gestione della batteria è stato scelto di adottare un approccio che prevede l'invio di nuovi aggiornamenti da parte del soggetto solo qual'ora il livello della batteria sia inferiore alla soglia critica, in modo da ridurre il numero di messaggi inviati dal soggetto stesso, prolungando la durata della sua batteria. Ricevuto il valore poi sarà carico del proxy aggiornare lo stato del soggetto \textit{virtuale} in modo che sia consistente con lo stato del relativo soggetto reale. \\
\lstinputlisting[language=Java,firstnumber=42, firstline=42, lastline=59,caption={SensorNode.UpdateBattery}]{../Codice/Java/ProxySubject/SensorNode.java}
\subsubsection{SensorData}
Questa classe si occupa invece di gestire e rendere facilmente accessibili i messaggi ottenuti dai soggetti, con le relative informazioni di contorno, come il soggetto mittente, la registrazione a cui quel valore è associato, il maxage del messaggio e se è o meno un messaggio critico. \\
\lstinputlisting[language=Java,firstnumber=7, firstline=7, lastline=11,caption={Attributi gestiti e offerti dalla classe SensorData}]{../Codice/Java/ProxySubject/SensorData.java}
